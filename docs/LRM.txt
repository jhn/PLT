<<<<<<< HEAD
n2n Reference Manual:1.	Introduction: description of n2n:a.	N2n is a computer language specific for coding graphs etc.2.	Lexical conventions: a.	Kinds of tokens (like identifiers, keyword, constants, strings, expression operators, and others)b.	Blanks spaces signify end of identifiersc.	Newlines indicate end of statementd.	Tabs indicate ___e.	Comments are ignored and are indicated by 2.1 Comments: Comments are ignored and are introduced by the character ; and terminated with a ;; .2.2 Identifiers: A sequence of letters and digits; the first character must be alphabetic. Upper and lower case letter are considered different. The underscore counts as alphabetic. Identifiers should be in snake-case; if an identifier is composed of more than one word, the words should be separated by the underscore character.2.3 Keywords: The following identifiers are reserved for use as keywords and may not be used otherwise: IntStringBoolDoubleDataifelseelifletNode (node type)fnvoidtruefalsereturn 2.3 Function keywords: (built-in function names)make_node() (constructor for node)rel()ins()rem()neighbors()add_field()	map(coll, fn)	reduce (coll, fn, init)	each(coll,fn)	filter(coll,pred)	2.3 Constants: Several kinds of constants:		2.3.1 Integer Constants- sequence of digits. Taken to be decimal always		2.3.2 Double Constants – consists of integer part, decimal point, and fraction part. The integer and fractions part both consist of a sequence of digits. Either the integer part or the fraction part (not both) may be missing. The decimal point may also be missing. 	2.4 Strings: sequence of characters surrounded by double quotesTo print certain non-graphic characters, precede them with back-slash. These include: \” , \n , \t , \r , \\ , \;3.	What’s in a name? The type of the identifier determines the meaning of the values in the identifier’s storage. The location and lifetime of an identifier are determined by the scope in which it is declared. A function sets a scope for a variable so that any variable declared in a function only exists within that function and are discarded on return. Any variable declared outside functions are global and visible by the entire program, independent of any function. If a local variable shares its name with a global variable, the local variable (within the function) has precedence. (copied from C manual – check to make sure this is true for us)	n2n supports four fundamental types of objects: integers, double-precision floating-point numbers, booleans, and strings		Integers (Int) are represented in 16-bit 2’s complement notation		Double-precision floating-point (Double) quantities have magnitudes in the range approximately 10+-38 or 0; and a precision of 56 bits or about 17 decimal digits		Booleans (Bool) can have only two values: true or false		Strings are composed of characters chosen from ASCII setBesides for these 4 fundamental types there are 4 derived types constructed from the fundamental types in the following ways:Data grouping basic and/or complex typesNodes containing some Data (instantiated either explicitly or implicitly)Relationships between nodes (instantiated explicitly or implicitly)Graphs representing a collection of nodes that may or may not have relationships to one anotherThere are also 2 types of collections built into n2n:Lists maintaining an ordered collection of elementsMaps storing key-value pairs4.	Objects and lvalues: An object is a manipulatable region of storage and is named as one of the above complex types. An lvalue is an expression referring to an object such as an identifier. For example, “Let r1: Relationship = [A 4 B]” creates a Relationship object with an lvalue called r1 that connects A and B via some named relationship of 4. 5.	Conversions ??? (Are we allowing conversions from ints-doubles or ints/doubles and strings? ??6.	Expressions ***LOOK IN PARSER TO SEE WHAT THEY DID***a.	Primary Expressions like . (dot operator) used to access a field in a Data object or groupingi.	Identifier is a primary expression provided it has been suitably declared as follows: using the key word “let” followed by an identifier name followed by a : , its type and possibly followed by an assignment (using the assignment operator =) ii.	Constant – Int, Double, Bool, String are all primary expressionsiii.	??? DO WE USE PARENS( expression ) A parenthesized expression is a primary expression whose type and value are identical to those of the unadorned expression. Parentheses merely come to set precedence’s or groupings of objects and/or values.iv.	Primary expression ( expression-list opt) A function call is followed by parentheses containing a possibly empty, comma-separated list of expressions which constitute the arguments to the function.***Passing by value??? Does function change formal and/or actual parameters???v.	{ expression } bracket expressions creates scope (as in a function) or groups data as in declaring Data groupings or Graph instantiationsvi.	Assignment operator [ expression ] – an assignment operator followed by square brackets is a primary expression and is used to define a relationship between two nodesvii.	Primary lavlue . member of Data group – An lvalue or identifier for the Data object followed by a member of the Data group. The object referred to by the lvalue is assumed to have the same form as the Data containing the member indicated. The result of the expression is an lvalue who type is that of the named Data member.b.	Unary Operatorsi.	– expression  results in the negative of the expressionii.	! expression results in true if the value of the expression is false and true if the expression value is falsec.	Multiplicative operatorsi.	Expression * expression : The * operator indicates multiplication. If both operands are Int the result is Int. Same with Double. If one is Int and the other Double, the result is Double (?RIGHT?)ii.	/ indicates division. The same type considerations as for multiplication apply. (**Do we want a % (modular) operator???***)d.	Additive Operatorsi.	Expression + expression: The result is the sum of the expressions. The same type considerations as for multiplication apply. ii.	Expression – expression: The result it the difference of the operandse.	Relational Operatorsi.	e < e and e > e and e <= e and e >=e all yield false if the specified relation is false and true if it is true. (***What types can be compared???***)f.	Equality Operatorsi.	The == (equal to) and the != (not equal to) operators are exactly analogous to the relational operators.g.	Expression && expression returns true if both expressions are true and false otherwiseh.	Expression || expression returns true if either experssion is true and false otherwisei.	Let lvalue : complex type = Is the way to declare an identifier using the equals sign (assignment operator) which means that the value of the expression replaces that of the object referred to by the lvalue. The expression must have the same type as the lvalue.*** DO WE DO DATA SWIMMING POOL{ TO DECLARE OR DO WE DO “LET SWIMMING POOL: DATA”???7.	Declarationsa.	Declarations are used within function definitions to specify the interpretation which n2n gives to each identifier. Declarations have the form: let name : type-specifier =opt or type-specifier name { exp }b.	The type-specifiers are: Int, Double, Bool, String, Graph, Node, Relationship, Data8.	Statements9.	External definitions10.	Scope rules11.	Compiler control lines12.	Implicit declarations13.	Types revisited14.	Constant expressions15.	ExamplesOperators: include double quotesThings changed from proposal:Comments: ; to start and ;; to endIn one example change Boolean to Bool5
=======
n2n Reference Manual:1. Introduction: description of n2n:a. N2n is a computer language specific for coding graphs etc.2. Lexical conventions: a. Kinds of tokens (like identifiers, keyword, constants, strings, expression operators, and others)b. Blanks spaces signify end of identifiersc. Newlines indicate end of statementd. Tabs indicate ___e. Comments are ignored and are indicated by __2.1 Comments: The character ; introduces a comment, and ;; ends it 2.2 Identifiers: A sequence of letters and digits; the first character must be alphabetic. Upper and lower case letter are considered different. The underscore counts as alphabetic.To declare an identifier, use the “let” keyword followed by the identifier name, a colon, and then the identifier type. For example: let length: Int2.3 Keywords: The following identifiers are reserved for use as keywords and may not be used otherwise:Int                 1String              1Bool                1Double              1Data                1if                  1else                1let                 1Node (node type)    1fn                  1void                1true                1false               1return              1Bill(From scanner):null                1      2.3 Function keywords: (built-in function names)node() (constructor for node)       1rel()                               1ins()                               1rem()                               1  neighbors()                       1  addField()                        1	map(coll, fn)                   1     	reduce (coll, fn, init)     1       	each(coll,fn)               1     	filter(coll,pred)           1          	2.3 Constants: Several kinds of constants:     		2.3.1 Integer Constants- sequence of digits. Taken to be decimal always     		2.3.2 Double Constants – consists of integer part, decimal point, and fraction part. The integer and fractions part both consist of a sequence of digits. Either the integer part or the fraction part (not both) may be missing. The decimal point may also be missing.      	2.4 Strings: sequence of characters surrounded by double quotes     To print certain non-graphic characters, precede them with back-slash. These include: \” , \n , \t , \r , \\ , \;3. Syntax Notation (maybe unnecessary)4. What’s in a name? The type of the identifier determines the meaning of the values in the identifier’s storage. The location and lifetime of an identifier are determined by the scope in which it is declared. A function sets a scope for a variable so that any variable declared in a function only exists within that function and are discarded on return. Any variable declared outside functions are global and visible by the entire program, independent of any function. If a local variable shares its name with a global variable, the local variable (within the function) has precedence.  the location where it is declared. (copied from C manual – check to make sure this is true for us)     	n2n supports four fundamental types of objects: integers, double-precision floating-point numbers, booleans, and strings     		Integers (Int) are represented in 16-bit 2’s complement notation     		Double-precision floating-point (Double) quantities have magnitudes in the range approximately 10+-38 or 0; and a precision of 56 bits or about 17 decimal digits     		Booleans (Bool) can have only two values: true or false     		Strings are composed of characters chosen from ASCII set     	There are also derived types constructed from the fundamental types:     		Map – a key-value store where keys and values can be of any type (but all keys are of the same type and all values are of the same type)     		List – an ordered collection of elements where all elements are of the same type5. Objects and lvaluesa. An lvalue is an expression referring to an object such as an identifier. To assign lvalues, use the keyword “let” followed by the identifier name followed by a colon. Example: let graph: Graph6. Conversions7. Expressions8. Declarations9. Statements10. External definitions11. Scope rules12. Compiler control lines13. Implicit declarations14. Types revisited15. Constant expressions16. ExamplesOperators: include double quotesThings changed from proposal:Comments: ; to start and ;; to endBill: The comment actually start and ends with ; for now.In one example change Boolean to Bool5
>>>>>>> b0be379a624b395c9c934062120ec59e92e8ba40
